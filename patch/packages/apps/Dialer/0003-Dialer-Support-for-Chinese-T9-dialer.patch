From 40b930090d7364e2c233dd364741d3e7eeaf05df Mon Sep 17 00:00:00 2001
From: Martincz Gao <martincz@mokeedev.com>
Date: Sun, 27 Jan 2019 10:24:02 +0800
Subject: [PATCH 3/3] Dialer: Support for Chinese T9 dialer

Change-Id: If00adefa450515b2bad60f7a4ec16a86da072161
---
 Android.mk                                    |   3 +
 .../dialer/database/DialerDatabaseHelper.java |  15 +-
 .../smartdial/map/BulgarianSmartDialMap.java  |  16 +
 .../smartdial/map/ChineseSmartDialMap.java    | 840 ++++++++++++++++++
 .../smartdial/map/CompositeSmartDialMap.java  |  17 +-
 .../smartdial/map/LatinSmartDialMap.java      |  16 +
 .../smartdial/map/RussianSmartDialMap.java    |  16 +
 .../dialer/smartdial/map/SmartDialMap.java    |  20 +-
 .../smartdial/map/UkrainianSmartDialMap.java  |  17 +
 .../smartdial/util/SmartDialNameMatcher.java  |  83 +-
 .../smartdial/util/SmartDialPrefix.java       |  22 +-
 11 files changed, 1012 insertions(+), 53 deletions(-)
 create mode 100644 java/com/android/dialer/smartdial/map/ChineseSmartDialMap.java

diff --git a/Android.mk b/Android.mk
index 84857f35..c106e501 100644
--- a/Android.mk
+++ b/Android.mk
@@ -72,6 +72,9 @@ LOCAL_FULL_LIBS_MANIFEST_FILES := \
 LOCAL_SRC_FILES := $(call all-java-files-under, $(BASE_DIR))
 LOCAL_SRC_FILES += $(call all-proto-files-under, $(BASE_DIR))
 LOCAL_SRC_FILES += $(call all-Iaidl-files-under, $(SRC_DIRS))
+LOCAL_SRC_FILES += ../../providers/ContactsProvider/src/com/android/providers/contacts/NameSplitter.java \
+                   ../../providers/ContactsProvider/src/com/android/providers/contacts/HanziToPinyin.java \
+                   ../../providers/ContactsProvider/src/com/android/providers/contacts/util/NeededForTesting.java
 LOCAL_SRC_FILES := $(filter-out $(EXCLUDE_FILES),$(LOCAL_SRC_FILES))
 
 LOCAL_PROTOC_FLAGS := --proto_path=$(LOCAL_PATH)
diff --git a/java/com/android/dialer/database/DialerDatabaseHelper.java b/java/com/android/dialer/database/DialerDatabaseHelper.java
index efff11ec..14e90df8 100644
--- a/java/com/android/dialer/database/DialerDatabaseHelper.java
+++ b/java/com/android/dialer/database/DialerDatabaseHelper.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2013 The Android Open Source Project
+ * Copyright (C) 2019 The MoKee Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -47,6 +48,8 @@ import com.android.dialer.database.FilteredNumberContract.FilteredNumberColumns;
 import com.android.dialer.smartdial.util.SmartDialNameMatcher;
 import com.android.dialer.smartdial.util.SmartDialPrefix;
 import com.android.dialer.util.PermissionsUtil;
+import com.google.android.collect.Lists;
+
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Objects;
@@ -82,7 +85,7 @@ public class DialerDatabaseHelper extends SQLiteOpenHelper {
   static final String DEFAULT_LAST_UPDATED_CONFIG_KEY = "smart_dial_default_last_update_millis";
 
   private static final String DATABASE_VERSION_PROPERTY = "database_version";
-  private static final int MAX_ENTRIES = 20;
+  private static final int MAX_ENTRIES = 40;
 
   private final Context context;
   private boolean isTestInstance = false;
@@ -880,10 +883,18 @@ public class DialerDatabaseHelper extends SQLiteOpenHelper {
   @WorkerThread
   public synchronized ArrayList<ContactNumber> getLooseMatches(
       String query, SmartDialNameMatcher nameMatcher) {
+    if (query.length() == 0) {
+      return Lists.newArrayList();
+    }
     final SQLiteDatabase db = getReadableDatabase();
 
     /** Uses SQL query wildcard '%' to represent prefix matching. */
-    final String looseQuery = query + "%";
+    StringBuilder looseQuery = new StringBuilder(query);
+    for (int i = 0; i < looseQuery.toString().length();) {
+      looseQuery.insert(i, "%");
+      i = i + 2;
+    }
+    looseQuery.append("%");
 
     final ArrayList<ContactNumber> result = new ArrayList<>();
 
diff --git a/java/com/android/dialer/smartdial/map/BulgarianSmartDialMap.java b/java/com/android/dialer/smartdial/map/BulgarianSmartDialMap.java
index 5be9761a..eae9543c 100644
--- a/java/com/android/dialer/smartdial/map/BulgarianSmartDialMap.java
+++ b/java/com/android/dialer/smartdial/map/BulgarianSmartDialMap.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2019 The MoKee Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +17,15 @@
 
 package com.android.dialer.smartdial.map;
 
+import android.content.Context;
 import android.support.v4.util.SimpleArrayMap;
 import com.android.dialer.dialpadview.DialpadCharMappings;
+import com.android.dialer.smartdial.util.SmartDialMatchPosition;
+import com.android.dialer.smartdial.util.SmartDialNameMatcher;
 import com.google.common.base.Optional;
 
+import java.util.ArrayList;
+
 /** A {@link SmartDialMap} for the Bulgarian alphabet. */
 @SuppressWarnings("Guava")
 final class BulgarianSmartDialMap extends SmartDialMap {
@@ -46,4 +52,14 @@ final class BulgarianSmartDialMap extends SmartDialMap {
   SimpleArrayMap<Character, Character> getCharToKeyMap() {
     return DialpadCharMappings.getCharToKeyMap("bul");
   }
+
+  @Override
+  public boolean matchesCombination(Context context, SmartDialNameMatcher smartDialNameMatcher, String displayName, String query, ArrayList<SmartDialMatchPosition> matchList) {
+    return smartDialNameMatcher.matchesCombination(context, displayName, query, matchList);
+  }
+
+  @Override
+  public String transliterateName(String index) {
+    return index;
+  }
 }
diff --git a/java/com/android/dialer/smartdial/map/ChineseSmartDialMap.java b/java/com/android/dialer/smartdial/map/ChineseSmartDialMap.java
new file mode 100644
index 00000000..eb69cb28
--- /dev/null
+++ b/java/com/android/dialer/smartdial/map/ChineseSmartDialMap.java
@@ -0,0 +1,840 @@
+/*
+ * Copyright (C) 2019 The MoKee Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.smartdial.map;
+
+import android.content.Context;
+import android.support.v4.util.SimpleArrayMap;
+import android.text.TextUtils;
+
+import com.android.dialer.dialpadview.DialpadCharMappings;
+import com.android.dialer.smartdial.util.SmartDialMatchPosition;
+import com.android.dialer.smartdial.util.SmartDialNameMatcher;
+import com.android.providers.contacts.HanziToPinyin;
+import com.google.common.base.Optional;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+
+public class ChineseSmartDialMap extends SmartDialMap {
+
+    private static ChineseSmartDialMap instance;
+
+    static ChineseSmartDialMap getInstance() {
+        if (instance == null) {
+            instance = new ChineseSmartDialMap();
+        }
+
+        return instance;
+    }
+
+    private ChineseSmartDialMap() {}
+
+    /*
+     * The switch statement in this function was generated using the python code:
+     * from unidecode import unidecode
+     * for i in range(192, 564):
+     *     char = unichr(i)
+     *     decoded = unidecode(char)
+     *     # Unicode characters that decompose into multiple characters i.e.
+     *     #  into ss are not supported for now
+     *     if (len(decoded) == 1 and decoded.isalpha()):
+     *         print "case '" + char + "': return Optional.of('" + unidecode(char) +  "');"
+     *
+     * This gives us a way to map characters containing accents/diacritics to their
+     * alphabetic equivalents. The unidecode library can be found at:
+     * http://pypi.python.org/pypi/Unidecode/0.04.1
+     *
+     * Also remaps all upper case latin characters to their lower case equivalents.
+     */
+    @Override
+    Optional<Character> normalizeCharacter(char ch) {
+        if (isValidDialpadAlphabeticChar(ch)) {
+            return Optional.of(ch);
+        }
+
+        switch (ch) {
+            case 'À':
+                return Optional.of('a');
+            case 'Á':
+                return Optional.of('a');
+            case 'Â':
+                return Optional.of('a');
+            case 'Ã':
+                return Optional.of('a');
+            case 'Ä':
+                return Optional.of('a');
+            case 'Å':
+                return Optional.of('a');
+            case 'Ç':
+                return Optional.of('c');
+            case 'È':
+                return Optional.of('e');
+            case 'É':
+                return Optional.of('e');
+            case 'Ê':
+                return Optional.of('e');
+            case 'Ë':
+                return Optional.of('e');
+            case 'Ì':
+                return Optional.of('i');
+            case 'Í':
+                return Optional.of('i');
+            case 'Î':
+                return Optional.of('i');
+            case 'Ï':
+                return Optional.of('i');
+            case 'Ð':
+                return Optional.of('d');
+            case 'Ñ':
+                return Optional.of('n');
+            case 'Ò':
+                return Optional.of('o');
+            case 'Ó':
+                return Optional.of('o');
+            case 'Ô':
+                return Optional.of('o');
+            case 'Õ':
+                return Optional.of('o');
+            case 'Ö':
+                return Optional.of('o');
+            case '×':
+                return Optional.of('x');
+            case 'Ø':
+                return Optional.of('o');
+            case 'Ù':
+                return Optional.of('u');
+            case 'Ú':
+                return Optional.of('u');
+            case 'Û':
+                return Optional.of('u');
+            case 'Ü':
+                return Optional.of('u');
+            case 'Ý':
+                return Optional.of('u');
+            case 'à':
+                return Optional.of('a');
+            case 'á':
+                return Optional.of('a');
+            case 'â':
+                return Optional.of('a');
+            case 'ã':
+                return Optional.of('a');
+            case 'ä':
+                return Optional.of('a');
+            case 'å':
+                return Optional.of('a');
+            case 'ç':
+                return Optional.of('c');
+            case 'è':
+                return Optional.of('e');
+            case 'é':
+                return Optional.of('e');
+            case 'ê':
+                return Optional.of('e');
+            case 'ë':
+                return Optional.of('e');
+            case 'ì':
+                return Optional.of('i');
+            case 'í':
+                return Optional.of('i');
+            case 'î':
+                return Optional.of('i');
+            case 'ï':
+                return Optional.of('i');
+            case 'ð':
+                return Optional.of('d');
+            case 'ñ':
+                return Optional.of('n');
+            case 'ò':
+                return Optional.of('o');
+            case 'ó':
+                return Optional.of('o');
+            case 'ô':
+                return Optional.of('o');
+            case 'õ':
+                return Optional.of('o');
+            case 'ö':
+                return Optional.of('o');
+            case 'ø':
+                return Optional.of('o');
+            case 'ù':
+                return Optional.of('u');
+            case 'ú':
+                return Optional.of('u');
+            case 'û':
+                return Optional.of('u');
+            case 'ü':
+                return Optional.of('u');
+            case 'ý':
+                return Optional.of('y');
+            case 'ÿ':
+                return Optional.of('y');
+            case 'Ā':
+                return Optional.of('a');
+            case 'ā':
+                return Optional.of('a');
+            case 'Ă':
+                return Optional.of('a');
+            case 'ă':
+                return Optional.of('a');
+            case 'Ą':
+                return Optional.of('a');
+            case 'ą':
+                return Optional.of('a');
+            case 'Ć':
+                return Optional.of('c');
+            case 'ć':
+                return Optional.of('c');
+            case 'Ĉ':
+                return Optional.of('c');
+            case 'ĉ':
+                return Optional.of('c');
+            case 'Ċ':
+                return Optional.of('c');
+            case 'ċ':
+                return Optional.of('c');
+            case 'Č':
+                return Optional.of('c');
+            case 'č':
+                return Optional.of('c');
+            case 'Ď':
+                return Optional.of('d');
+            case 'ď':
+                return Optional.of('d');
+            case 'Đ':
+                return Optional.of('d');
+            case 'đ':
+                return Optional.of('d');
+            case 'Ē':
+                return Optional.of('e');
+            case 'ē':
+                return Optional.of('e');
+            case 'Ĕ':
+                return Optional.of('e');
+            case 'ĕ':
+                return Optional.of('e');
+            case 'Ė':
+                return Optional.of('e');
+            case 'ė':
+                return Optional.of('e');
+            case 'Ę':
+                return Optional.of('e');
+            case 'ę':
+                return Optional.of('e');
+            case 'Ě':
+                return Optional.of('e');
+            case 'ě':
+                return Optional.of('e');
+            case 'Ĝ':
+                return Optional.of('g');
+            case 'ĝ':
+                return Optional.of('g');
+            case 'Ğ':
+                return Optional.of('g');
+            case 'ğ':
+                return Optional.of('g');
+            case 'Ġ':
+                return Optional.of('g');
+            case 'ġ':
+                return Optional.of('g');
+            case 'Ģ':
+                return Optional.of('g');
+            case 'ģ':
+                return Optional.of('g');
+            case 'Ĥ':
+                return Optional.of('h');
+            case 'ĥ':
+                return Optional.of('h');
+            case 'Ħ':
+                return Optional.of('h');
+            case 'ħ':
+                return Optional.of('h');
+            case 'Ĩ':
+                return Optional.of('i');
+            case 'ĩ':
+                return Optional.of('i');
+            case 'Ī':
+                return Optional.of('i');
+            case 'ī':
+                return Optional.of('i');
+            case 'Ĭ':
+                return Optional.of('i');
+            case 'ĭ':
+                return Optional.of('i');
+            case 'Į':
+                return Optional.of('i');
+            case 'į':
+                return Optional.of('i');
+            case 'İ':
+                return Optional.of('i');
+            case 'ı':
+                return Optional.of('i');
+            case 'Ĵ':
+                return Optional.of('j');
+            case 'ĵ':
+                return Optional.of('j');
+            case 'Ķ':
+                return Optional.of('k');
+            case 'ķ':
+                return Optional.of('k');
+            case 'ĸ':
+                return Optional.of('k');
+            case 'Ĺ':
+                return Optional.of('l');
+            case 'ĺ':
+                return Optional.of('l');
+            case 'Ļ':
+                return Optional.of('l');
+            case 'ļ':
+                return Optional.of('l');
+            case 'Ľ':
+                return Optional.of('l');
+            case 'ľ':
+                return Optional.of('l');
+            case 'Ŀ':
+                return Optional.of('l');
+            case 'ŀ':
+                return Optional.of('l');
+            case 'Ł':
+                return Optional.of('l');
+            case 'ł':
+                return Optional.of('l');
+            case 'Ń':
+                return Optional.of('n');
+            case 'ń':
+                return Optional.of('n');
+            case 'Ņ':
+                return Optional.of('n');
+            case 'ņ':
+                return Optional.of('n');
+            case 'Ň':
+                return Optional.of('n');
+            case 'ň':
+                return Optional.of('n');
+            case 'Ō':
+                return Optional.of('o');
+            case 'ō':
+                return Optional.of('o');
+            case 'Ŏ':
+                return Optional.of('o');
+            case 'ŏ':
+                return Optional.of('o');
+            case 'Ő':
+                return Optional.of('o');
+            case 'ő':
+                return Optional.of('o');
+            case 'Ŕ':
+                return Optional.of('r');
+            case 'ŕ':
+                return Optional.of('r');
+            case 'Ŗ':
+                return Optional.of('r');
+            case 'ŗ':
+                return Optional.of('r');
+            case 'Ř':
+                return Optional.of('r');
+            case 'ř':
+                return Optional.of('r');
+            case 'Ś':
+                return Optional.of('s');
+            case 'ś':
+                return Optional.of('s');
+            case 'Ŝ':
+                return Optional.of('s');
+            case 'ŝ':
+                return Optional.of('s');
+            case 'Ş':
+                return Optional.of('s');
+            case 'ş':
+                return Optional.of('s');
+            case 'Š':
+                return Optional.of('s');
+            case 'š':
+                return Optional.of('s');
+            case 'Ţ':
+                return Optional.of('t');
+            case 'ţ':
+                return Optional.of('t');
+            case 'Ť':
+                return Optional.of('t');
+            case 'ť':
+                return Optional.of('t');
+            case 'Ŧ':
+                return Optional.of('t');
+            case 'ŧ':
+                return Optional.of('t');
+            case 'Ũ':
+                return Optional.of('u');
+            case 'ũ':
+                return Optional.of('u');
+            case 'Ū':
+                return Optional.of('u');
+            case 'ū':
+                return Optional.of('u');
+            case 'Ŭ':
+                return Optional.of('u');
+            case 'ŭ':
+                return Optional.of('u');
+            case 'Ů':
+                return Optional.of('u');
+            case 'ů':
+                return Optional.of('u');
+            case 'Ű':
+                return Optional.of('u');
+            case 'ű':
+                return Optional.of('u');
+            case 'Ų':
+                return Optional.of('u');
+            case 'ų':
+                return Optional.of('u');
+            case 'Ŵ':
+                return Optional.of('w');
+            case 'ŵ':
+                return Optional.of('w');
+            case 'Ŷ':
+                return Optional.of('y');
+            case 'ŷ':
+                return Optional.of('y');
+            case 'Ÿ':
+                return Optional.of('y');
+            case 'Ź':
+                return Optional.of('z');
+            case 'ź':
+                return Optional.of('z');
+            case 'Ż':
+                return Optional.of('z');
+            case 'ż':
+                return Optional.of('z');
+            case 'Ž':
+                return Optional.of('z');
+            case 'ž':
+                return Optional.of('z');
+            case 'ſ':
+                return Optional.of('s');
+            case 'ƀ':
+                return Optional.of('b');
+            case 'Ɓ':
+                return Optional.of('b');
+            case 'Ƃ':
+                return Optional.of('b');
+            case 'ƃ':
+                return Optional.of('b');
+            case 'Ɔ':
+                return Optional.of('o');
+            case 'Ƈ':
+                return Optional.of('c');
+            case 'ƈ':
+                return Optional.of('c');
+            case 'Ɖ':
+                return Optional.of('d');
+            case 'Ɗ':
+                return Optional.of('d');
+            case 'Ƌ':
+                return Optional.of('d');
+            case 'ƌ':
+                return Optional.of('d');
+            case 'ƍ':
+                return Optional.of('d');
+            case 'Ɛ':
+                return Optional.of('e');
+            case 'Ƒ':
+                return Optional.of('f');
+            case 'ƒ':
+                return Optional.of('f');
+            case 'Ɠ':
+                return Optional.of('g');
+            case 'Ɣ':
+                return Optional.of('g');
+            case 'Ɩ':
+                return Optional.of('i');
+            case 'Ɨ':
+                return Optional.of('i');
+            case 'Ƙ':
+                return Optional.of('k');
+            case 'ƙ':
+                return Optional.of('k');
+            case 'ƚ':
+                return Optional.of('l');
+            case 'ƛ':
+                return Optional.of('l');
+            case 'Ɯ':
+                return Optional.of('w');
+            case 'Ɲ':
+                return Optional.of('n');
+            case 'ƞ':
+                return Optional.of('n');
+            case 'Ɵ':
+                return Optional.of('o');
+            case 'Ơ':
+                return Optional.of('o');
+            case 'ơ':
+                return Optional.of('o');
+            case 'Ƥ':
+                return Optional.of('p');
+            case 'ƥ':
+                return Optional.of('p');
+            case 'ƫ':
+                return Optional.of('t');
+            case 'Ƭ':
+                return Optional.of('t');
+            case 'ƭ':
+                return Optional.of('t');
+            case 'Ʈ':
+                return Optional.of('t');
+            case 'Ư':
+                return Optional.of('u');
+            case 'ư':
+                return Optional.of('u');
+            case 'Ʊ':
+                return Optional.of('y');
+            case 'Ʋ':
+                return Optional.of('v');
+            case 'Ƴ':
+                return Optional.of('y');
+            case 'ƴ':
+                return Optional.of('y');
+            case 'Ƶ':
+                return Optional.of('z');
+            case 'ƶ':
+                return Optional.of('z');
+            case 'ƿ':
+                return Optional.of('w');
+            case 'Ǎ':
+                return Optional.of('a');
+            case 'ǎ':
+                return Optional.of('a');
+            case 'Ǐ':
+                return Optional.of('i');
+            case 'ǐ':
+                return Optional.of('i');
+            case 'Ǒ':
+                return Optional.of('o');
+            case 'ǒ':
+                return Optional.of('o');
+            case 'Ǔ':
+                return Optional.of('u');
+            case 'ǔ':
+                return Optional.of('u');
+            case 'Ǖ':
+                return Optional.of('u');
+            case 'ǖ':
+                return Optional.of('u');
+            case 'Ǘ':
+                return Optional.of('u');
+            case 'ǘ':
+                return Optional.of('u');
+            case 'Ǚ':
+                return Optional.of('u');
+            case 'ǚ':
+                return Optional.of('u');
+            case 'Ǜ':
+                return Optional.of('u');
+            case 'ǜ':
+                return Optional.of('u');
+            case 'Ǟ':
+                return Optional.of('a');
+            case 'ǟ':
+                return Optional.of('a');
+            case 'Ǡ':
+                return Optional.of('a');
+            case 'ǡ':
+                return Optional.of('a');
+            case 'Ǥ':
+                return Optional.of('g');
+            case 'ǥ':
+                return Optional.of('g');
+            case 'Ǧ':
+                return Optional.of('g');
+            case 'ǧ':
+                return Optional.of('g');
+            case 'Ǩ':
+                return Optional.of('k');
+            case 'ǩ':
+                return Optional.of('k');
+            case 'Ǫ':
+                return Optional.of('o');
+            case 'ǫ':
+                return Optional.of('o');
+            case 'Ǭ':
+                return Optional.of('o');
+            case 'ǭ':
+                return Optional.of('o');
+            case 'ǰ':
+                return Optional.of('j');
+            case 'ǲ':
+                return Optional.of('d');
+            case 'Ǵ':
+                return Optional.of('g');
+            case 'ǵ':
+                return Optional.of('g');
+            case 'Ƿ':
+                return Optional.of('w');
+            case 'Ǹ':
+                return Optional.of('n');
+            case 'ǹ':
+                return Optional.of('n');
+            case 'Ǻ':
+                return Optional.of('a');
+            case 'ǻ':
+                return Optional.of('a');
+            case 'Ǿ':
+                return Optional.of('o');
+            case 'ǿ':
+                return Optional.of('o');
+            case 'Ȁ':
+                return Optional.of('a');
+            case 'ȁ':
+                return Optional.of('a');
+            case 'Ȃ':
+                return Optional.of('a');
+            case 'ȃ':
+                return Optional.of('a');
+            case 'Ȅ':
+                return Optional.of('e');
+            case 'ȅ':
+                return Optional.of('e');
+            case 'Ȇ':
+                return Optional.of('e');
+            case 'ȇ':
+                return Optional.of('e');
+            case 'Ȉ':
+                return Optional.of('i');
+            case 'ȉ':
+                return Optional.of('i');
+            case 'Ȋ':
+                return Optional.of('i');
+            case 'ȋ':
+                return Optional.of('i');
+            case 'Ȍ':
+                return Optional.of('o');
+            case 'ȍ':
+                return Optional.of('o');
+            case 'Ȏ':
+                return Optional.of('o');
+            case 'ȏ':
+                return Optional.of('o');
+            case 'Ȑ':
+                return Optional.of('r');
+            case 'ȑ':
+                return Optional.of('r');
+            case 'Ȓ':
+                return Optional.of('r');
+            case 'ȓ':
+                return Optional.of('r');
+            case 'Ȕ':
+                return Optional.of('u');
+            case 'ȕ':
+                return Optional.of('u');
+            case 'Ȗ':
+                return Optional.of('u');
+            case 'ȗ':
+                return Optional.of('u');
+            case 'Ș':
+                return Optional.of('s');
+            case 'ș':
+                return Optional.of('s');
+            case 'Ț':
+                return Optional.of('t');
+            case 'ț':
+                return Optional.of('t');
+            case 'Ȝ':
+                return Optional.of('y');
+            case 'ȝ':
+                return Optional.of('y');
+            case 'Ȟ':
+                return Optional.of('h');
+            case 'ȟ':
+                return Optional.of('h');
+            case 'Ȥ':
+                return Optional.of('z');
+            case 'ȥ':
+                return Optional.of('z');
+            case 'Ȧ':
+                return Optional.of('a');
+            case 'ȧ':
+                return Optional.of('a');
+            case 'Ȩ':
+                return Optional.of('e');
+            case 'ȩ':
+                return Optional.of('e');
+            case 'Ȫ':
+                return Optional.of('o');
+            case 'ȫ':
+                return Optional.of('o');
+            case 'Ȭ':
+                return Optional.of('o');
+            case 'ȭ':
+                return Optional.of('o');
+            case 'Ȯ':
+                return Optional.of('o');
+            case 'ȯ':
+                return Optional.of('o');
+            case 'Ȱ':
+                return Optional.of('o');
+            case 'ȱ':
+                return Optional.of('o');
+            case 'Ȳ':
+                return Optional.of('y');
+            case 'ȳ':
+                return Optional.of('y');
+            case 'A':
+                return Optional.of('a');
+            case 'B':
+                return Optional.of('b');
+            case 'C':
+                return Optional.of('c');
+            case 'D':
+                return Optional.of('d');
+            case 'E':
+                return Optional.of('e');
+            case 'F':
+                return Optional.of('f');
+            case 'G':
+                return Optional.of('g');
+            case 'H':
+                return Optional.of('h');
+            case 'I':
+                return Optional.of('i');
+            case 'J':
+                return Optional.of('j');
+            case 'K':
+                return Optional.of('k');
+            case 'L':
+                return Optional.of('l');
+            case 'M':
+                return Optional.of('m');
+            case 'N':
+                return Optional.of('n');
+            case 'O':
+                return Optional.of('o');
+            case 'P':
+                return Optional.of('p');
+            case 'Q':
+                return Optional.of('q');
+            case 'R':
+                return Optional.of('r');
+            case 'S':
+                return Optional.of('s');
+            case 'T':
+                return Optional.of('t');
+            case 'U':
+                return Optional.of('u');
+            case 'V':
+                return Optional.of('v');
+            case 'W':
+                return Optional.of('w');
+            case 'X':
+                return Optional.of('x');
+            case 'Y':
+                return Optional.of('y');
+            case 'Z':
+                return Optional.of('z');
+            default:
+                return Optional.absent();
+        }
+    }
+
+    @Override
+    SimpleArrayMap<Character, Character> getCharToKeyMap() {
+        return DialpadCharMappings.getDefaultCharToKeyMap();
+    }
+
+    /*
+     * Generates a space delimited string of pinyins
+     */
+    private String tokenizeToPinyins(String displayName) {
+        HanziToPinyin hanziToPinyin = HanziToPinyin.getInstance();
+        ArrayList<HanziToPinyin.Token> tokens = hanziToPinyin.getTokens(displayName);
+        ArrayList<String> pinyins = new ArrayList<String>();
+        for (HanziToPinyin.Token token : tokens) {
+            if (token.type != HanziToPinyin.Token.PINYIN) {
+                return displayName;
+            } else {
+                pinyins.add(token.target);
+            }
+        }
+        return TextUtils.join(" ", pinyins);
+    }
+
+    @Override
+    public String transliterateName(String index) {
+        return tokenizeToPinyins(index);
+    }
+
+    /*
+     * Uses the default matching logic on the pinyin name and attempts to map the match positions
+     * back to the original display name
+     */
+    @Override
+    public boolean matchesCombination(Context context, SmartDialNameMatcher smartDialNameMatcher,
+            String displayName, String query, ArrayList<SmartDialMatchPosition> matchList) {
+
+        String pinyinName = tokenizeToPinyins(displayName);
+
+        ArrayList<SmartDialMatchPosition> computedMatchList = new ArrayList<>();
+        boolean matches = smartDialNameMatcher.matchesCombination(context, pinyinName, query, computedMatchList);
+        if (!matches)
+            return false;
+
+        // name was translated to pinyin before matching.  attempt to map the match positions
+        // back to the original display string
+        if (!displayName.equals(pinyinName)) {
+
+            // construct an array that maps each character of the pinyin name back to the index of
+            // the hanzi token from which it came
+            // For example, if:
+            //  displayName = 红霞李
+            //  pinyinName =  "hong xia li"
+            // then:
+            //  pinyinMapping = 0,0,0,0,-1,1,1,1,-1,2,2
+            int[] pinyinMapping = new int[pinyinName.length()];
+            int curToken = 0;
+            for (int i=0; i < pinyinName.length(); ++i) {
+                char c = pinyinName.charAt(i);
+                if (c == ' ') {
+                    ++curToken;
+                    pinyinMapping[i] = -1;
+                }
+                else {
+                    pinyinMapping[i] = curToken;
+                }
+            }
+
+            // calculate unique hanzi characters that are matched
+            Set<Integer> positionsToHighlight = new HashSet<>();
+            for (SmartDialMatchPosition matchPosition : computedMatchList) {
+                for (int pos = matchPosition.start; pos < matchPosition.end; ++pos) {
+                    int mappedPos = pinyinMapping[pos];
+                    if (mappedPos >= 0)
+                        positionsToHighlight.add(mappedPos);
+                }
+            }
+
+            // reset computed matches
+            computedMatchList = new ArrayList<>();
+            for (int matchPos : positionsToHighlight) {
+                // use one object per position for simplicity
+                computedMatchList.add(new SmartDialMatchPosition(matchPos, matchPos+1));
+            }
+        }
+
+        matchList.addAll(computedMatchList);
+        return true;
+    }
+
+}
diff --git a/java/com/android/dialer/smartdial/map/CompositeSmartDialMap.java b/java/com/android/dialer/smartdial/map/CompositeSmartDialMap.java
index 112cb19b..dc75f59d 100644
--- a/java/com/android/dialer/smartdial/map/CompositeSmartDialMap.java
+++ b/java/com/android/dialer/smartdial/map/CompositeSmartDialMap.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2019 The MoKee Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,8 +21,12 @@ import android.content.Context;
 import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.SimpleArrayMap;
 import com.android.dialer.compat.CompatUtils;
+import com.android.dialer.smartdial.util.SmartDialMatchPosition;
+import com.android.dialer.smartdial.util.SmartDialNameMatcher;
 import com.google.common.base.Optional;
 
+import java.util.ArrayList;
+
 /**
  * A utility class that combines the functionality of two implementations of {@link SmartDialMap} so
  * that we support smart dial for dual alphabets.
@@ -45,6 +50,7 @@ public class CompositeSmartDialMap {
     EXTRA_MAPS.put("bul", BulgarianSmartDialMap.getInstance());
     EXTRA_MAPS.put("rus", RussianSmartDialMap.getInstance());
     EXTRA_MAPS.put("ukr", UkrainianSmartDialMap.getInstance());
+    EXTRA_MAPS.put("zho", ChineseSmartDialMap.getInstance());
   }
 
   private CompositeSmartDialMap() {}
@@ -156,10 +162,19 @@ public class CompositeSmartDialMap {
   }
 
   @VisibleForTesting
-  static Optional<SmartDialMap> getExtraMap(Context context) {
+  public static Optional<SmartDialMap> getExtraMap(Context context) {
     String languageCode = CompatUtils.getLocale(context).getISO3Language();
     return EXTRA_MAPS.containsKey(languageCode)
         ? Optional.of(EXTRA_MAPS.get(languageCode))
         : Optional.absent();
   }
+
+  public static boolean matchesCombination(Context context, SmartDialNameMatcher smartDialNameMatcher, String displayName, String query, ArrayList<SmartDialMatchPosition> matchPositions) {
+    Optional<SmartDialMap> extraMap = getExtraMap(context);
+    if (extraMap.isPresent()) {
+      return extraMap.get().matchesCombination(context, smartDialNameMatcher, displayName, query, matchPositions);
+    } else {
+      return smartDialNameMatcher.matchesCombination(context, displayName, query, matchPositions);
+    }
+  }
 }
diff --git a/java/com/android/dialer/smartdial/map/LatinSmartDialMap.java b/java/com/android/dialer/smartdial/map/LatinSmartDialMap.java
index b8ef951c..d8d16fdb 100644
--- a/java/com/android/dialer/smartdial/map/LatinSmartDialMap.java
+++ b/java/com/android/dialer/smartdial/map/LatinSmartDialMap.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2016 The Android Open Source Project
+ * Copyright (C) 2019 The MoKee Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +17,15 @@
 
 package com.android.dialer.smartdial.map;
 
+import android.content.Context;
 import android.support.v4.util.SimpleArrayMap;
 import com.android.dialer.dialpadview.DialpadCharMappings;
+import com.android.dialer.smartdial.util.SmartDialMatchPosition;
+import com.android.dialer.smartdial.util.SmartDialNameMatcher;
 import com.google.common.base.Optional;
 
+import java.util.ArrayList;
+
 /** A {@link SmartDialMap} for the Latin alphabet, which is for T9 dialpad searching. */
 @SuppressWarnings("Guava")
 final class LatinSmartDialMap extends SmartDialMap {
@@ -745,4 +751,14 @@ final class LatinSmartDialMap extends SmartDialMap {
   SimpleArrayMap<Character, Character> getCharToKeyMap() {
     return DialpadCharMappings.getDefaultCharToKeyMap();
   }
+
+  @Override
+  public boolean matchesCombination(Context context, SmartDialNameMatcher smartDialNameMatcher, String displayName, String query, ArrayList<SmartDialMatchPosition> matchList) {
+    return smartDialNameMatcher.matchesCombination(context, displayName, query, matchList);
+  }
+
+  @Override
+  public String transliterateName(String index) {
+    return index;
+  }
 }
diff --git a/java/com/android/dialer/smartdial/map/RussianSmartDialMap.java b/java/com/android/dialer/smartdial/map/RussianSmartDialMap.java
index c10bbb0c..dfab6d43 100644
--- a/java/com/android/dialer/smartdial/map/RussianSmartDialMap.java
+++ b/java/com/android/dialer/smartdial/map/RussianSmartDialMap.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2019 The MoKee Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +17,15 @@
 
 package com.android.dialer.smartdial.map;
 
+import android.content.Context;
 import android.support.v4.util.SimpleArrayMap;
 import com.android.dialer.dialpadview.DialpadCharMappings;
+import com.android.dialer.smartdial.util.SmartDialMatchPosition;
+import com.android.dialer.smartdial.util.SmartDialNameMatcher;
 import com.google.common.base.Optional;
 
+import java.util.ArrayList;
+
 /** A {@link SmartDialMap} for the Russian alphabet. */
 @SuppressWarnings("Guava")
 final class RussianSmartDialMap extends SmartDialMap {
@@ -46,4 +52,14 @@ final class RussianSmartDialMap extends SmartDialMap {
   SimpleArrayMap<Character, Character> getCharToKeyMap() {
     return DialpadCharMappings.getCharToKeyMap("rus");
   }
+
+  @Override
+  public boolean matchesCombination(Context context, SmartDialNameMatcher smartDialNameMatcher, String displayName, String query, ArrayList<SmartDialMatchPosition> matchList) {
+    return smartDialNameMatcher.matchesCombination(context, displayName, query, matchList);
+  }
+
+  @Override
+  public String transliterateName(String index) {
+    return index;
+  }
 }
diff --git a/java/com/android/dialer/smartdial/map/SmartDialMap.java b/java/com/android/dialer/smartdial/map/SmartDialMap.java
index c74dd289..f2dd5d5f 100644
--- a/java/com/android/dialer/smartdial/map/SmartDialMap.java
+++ b/java/com/android/dialer/smartdial/map/SmartDialMap.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2016 The Android Open Source Project
+ * Copyright (C) 2019 The MoKee Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +17,18 @@
 
 package com.android.dialer.smartdial.map;
 
+import android.content.Context;
 import android.support.v4.util.SimpleArrayMap;
+
+import com.android.dialer.smartdial.util.SmartDialMatchPosition;
+import com.android.dialer.smartdial.util.SmartDialNameMatcher;
 import com.google.common.base.Optional;
 
+import java.util.ArrayList;
+
 /** Definition for utilities that supports smart dial in different languages. */
 @SuppressWarnings("Guava")
-abstract class SmartDialMap {
+public abstract class SmartDialMap {
 
   /**
    * Returns true if the provided character can be mapped to a key on the dialpad.
@@ -100,4 +107,15 @@ abstract class SmartDialMap {
    * dialpad key.
    */
   abstract SimpleArrayMap<Character, Character> getCharToKeyMap();
+
+  /*
+   * Allow the SmartDialMaps to convert the characters if needed.
+   */
+  public abstract String transliterateName(String index);
+
+  /*
+   * Allow the SmartDialMaps to provide their own character to dialpad matching if needed.
+   */
+  public abstract boolean matchesCombination(Context context, SmartDialNameMatcher smartDialNameMatcher, String displayName, String query,
+                                      ArrayList<SmartDialMatchPosition> matchList);
 }
diff --git a/java/com/android/dialer/smartdial/map/UkrainianSmartDialMap.java b/java/com/android/dialer/smartdial/map/UkrainianSmartDialMap.java
index 844732c3..ba680018 100644
--- a/java/com/android/dialer/smartdial/map/UkrainianSmartDialMap.java
+++ b/java/com/android/dialer/smartdial/map/UkrainianSmartDialMap.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2019 The MoKee Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +17,15 @@
 
 package com.android.dialer.smartdial.map;
 
+import android.content.Context;
 import android.support.v4.util.SimpleArrayMap;
 import com.android.dialer.dialpadview.DialpadCharMappings;
+import com.android.dialer.smartdial.util.SmartDialMatchPosition;
+import com.android.dialer.smartdial.util.SmartDialNameMatcher;
 import com.google.common.base.Optional;
 
+import java.util.ArrayList;
+
 /** A {@link SmartDialMap} for the Ukrainian alphabet. */
 final class UkrainianSmartDialMap extends SmartDialMap {
 
@@ -45,4 +51,15 @@ final class UkrainianSmartDialMap extends SmartDialMap {
   SimpleArrayMap<Character, Character> getCharToKeyMap() {
     return DialpadCharMappings.getCharToKeyMap("ukr");
   }
+
+  @Override
+  public boolean matchesCombination(Context context, SmartDialNameMatcher smartDialNameMatcher, String displayName, String query, ArrayList<SmartDialMatchPosition> matchList) {
+    return smartDialNameMatcher.matchesCombination(context, displayName, query, matchList);
+  }
+
+  @Override
+  public String transliterateName(String index) {
+    return index;
+  }
+
 }
diff --git a/java/com/android/dialer/smartdial/util/SmartDialNameMatcher.java b/java/com/android/dialer/smartdial/util/SmartDialNameMatcher.java
index 60196229..ec66fc5b 100644
--- a/java/com/android/dialer/smartdial/util/SmartDialNameMatcher.java
+++ b/java/com/android/dialer/smartdial/util/SmartDialNameMatcher.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (C) 2019 The MoKee Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,7 +21,7 @@ import android.content.Context;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.android.dialer.smartdial.map.CompositeSmartDialMap;
-import com.android.dialer.smartdial.util.SmartDialPrefix.PhoneNumberTokens;
+
 import java.util.ArrayList;
 
 /**
@@ -44,6 +45,8 @@ public class SmartDialNameMatcher {
   // Controls whether to treat an empty query as a match (with anything).
   private boolean shouldMatchEmptyQuery = false;
 
+  private String schar = "+*#-.(,)/ ";
+
   public SmartDialNameMatcher(String query) {
     this.query = query;
   }
@@ -120,19 +123,6 @@ public class SmartDialNameMatcher {
     // Try matching the number as is
     SmartDialMatchPosition matchPos =
         matchesNumberWithOffset(context, phoneNumber, query, /* offset = */ 0);
-    if (matchPos == null) {
-      PhoneNumberTokens phoneNumberTokens = SmartDialPrefix.parsePhoneNumber(context, phoneNumber);
-
-      if (phoneNumberTokens.countryCodeOffset != 0) {
-        matchPos =
-            matchesNumberWithOffset(
-                context, phoneNumber, query, phoneNumberTokens.countryCodeOffset);
-      }
-      if (matchPos == null && phoneNumberTokens.nanpCodeOffset != 0) {
-        matchPos =
-            matchesNumberWithOffset(context, phoneNumber, query, phoneNumberTokens.nanpCodeOffset);
-      }
-    }
     if (matchPos != null) {
       replaceBitInMask(builder, matchPos);
     }
@@ -163,40 +153,47 @@ public class SmartDialNameMatcher {
    */
   private SmartDialMatchPosition matchesNumberWithOffset(
       Context context, String phoneNumber, String query, int offset) {
-    if (TextUtils.isEmpty(phoneNumber) || TextUtils.isEmpty(query)) {
+    if (TextUtils.isEmpty(phoneNumber) || TextUtils.isEmpty(query)
+            || query.length() > phoneNumber.length()) {
       return shouldMatchEmptyQuery ? new SmartDialMatchPosition(offset, offset) : null;
     }
-    int queryAt = 0;
-    int numberAt = offset;
-    for (int i = offset; i < phoneNumber.length(); i++) {
-      if (queryAt == query.length()) {
-        break;
+
+    String phoneNum = phoneNumber.replaceAll("[\\+\\*\\#\\-\\.\\(\\,\\)\\/ ]", "");
+    if (!TextUtils.isEmpty(phoneNum) && phoneNum.contains(query)) {
+      // firstly, find the start position in original phone number.
+      int start = phoneNum.indexOf(query);
+      int length = phoneNumber.length();
+      for (int i = start; i < length; i++) {
+        char ch = phoneNumber.charAt(i);
+        if (ch != phoneNum.charAt(start)) {
+          continue;
+        }
+        if (phoneNumber.substring(i).replaceAll("[\\+\\*\\#\\-\\.\\(\\,\\)\\/ ]", "")
+                .indexOf(query) == 0) {
+          start = i;
+          break;
+        }
       }
-      char ch = phoneNumber.charAt(i);
-      if (CompositeSmartDialMap.isValidDialpadNumericChar(context, ch)) {
-        if (ch != query.charAt(queryAt)) {
-          return null;
+      // secondly, find the end position in original phone number.
+      int specialCount = 0;
+      int queryLength = query.length();
+      int end = start + queryLength;
+      for (int i = start; i < length; i++) {
+        char ch = phoneNumber.charAt(i);
+        if (schar.indexOf(ch) != -1) {
+          specialCount++;
+          continue;
         }
-        queryAt++;
-      } else {
-        if (queryAt == 0) {
-          // Found a separator before any part of the query was matched, so advance the
-          // offset to avoid prematurely highlighting separators before the rest of the
-          // query.
-          // E.g. don't highlight the first '-' if we're matching 1-510-111-1111 with
-          // '510'.
-          // However, if the current offset is 0, just include the beginning separators
-          // anyway, otherwise the highlighting ends up looking weird.
-          // E.g. if we're matching (510)-111-1111 with '510', we should include the
-          // first '('.
-          if (offset != 0) {
-            offset++;
-          }
+
+        if (i - start + 1 - specialCount == queryLength) {
+          end = i + 1;
+          break;
         }
       }
-      numberAt++;
+      return new SmartDialMatchPosition(start, end);
+    } else {
+      return null;
     }
-    return new SmartDialMatchPosition(0 + offset, numberAt);
   }
 
   /**
@@ -226,7 +223,7 @@ public class SmartDialNameMatcher {
    *     contained in query. If the function returns true, matchList will contain an ArrayList of
    *     match positions (multiple matches correspond to initial matches).
    */
-  private boolean matchesCombination(
+  public boolean matchesCombination(
       Context context,
       String displayName,
       String query,
@@ -407,7 +404,7 @@ public class SmartDialNameMatcher {
    */
   public boolean matches(Context context, String displayName) {
     matchPositions.clear();
-    return matchesCombination(context, displayName, query, matchPositions);
+    return CompositeSmartDialMap.matchesCombination(context, this, displayName, query, matchPositions);
   }
 
   public ArrayList<SmartDialMatchPosition> getMatchPositions() {
diff --git a/java/com/android/dialer/smartdial/util/SmartDialPrefix.java b/java/com/android/dialer/smartdial/util/SmartDialPrefix.java
index 7fef8814..380c2f4d 100644
--- a/java/com/android/dialer/smartdial/util/SmartDialPrefix.java
+++ b/java/com/android/dialer/smartdial/util/SmartDialPrefix.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2013 The Android Open Source Project
+ * Copyright (C) 2019 The MoKee Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,6 +24,9 @@ import android.support.annotation.VisibleForTesting;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import com.android.dialer.smartdial.map.CompositeSmartDialMap;
+import com.android.dialer.smartdial.map.SmartDialMap;
+import com.google.common.base.Optional;
+
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Set;
@@ -64,6 +68,9 @@ public class SmartDialPrefix {
 
   private static boolean nanpInitialized = false;
 
+  /** Dialpad extra mapping. */
+  private static Optional<SmartDialMap> extraMap = null;
+
   /** Initializes the Nanp settings, and finds out whether user is in a NANP region. */
   public static void initializeNanpSettings(Context context) {
     final TelephonyManager manager =
@@ -85,6 +92,7 @@ public class SmartDialPrefix {
     }
     /** Queries the NANP country list to find out whether user is in a NANP region. */
     userInNanpRegion = isCountryNanp(userSimCountryCode);
+    extraMap = CompositeSmartDialMap.getExtraMap(context);
     nanpInitialized = true;
   }
 
@@ -133,6 +141,9 @@ public class SmartDialPrefix {
    */
   public static ArrayList<String> generateNamePrefixes(Context context, String index) {
     final ArrayList<String> result = new ArrayList<>();
+    if (extraMap.isPresent()) {
+      index = extraMap.get().transliterateName(index);
+    }
 
     /** Parses the name into a list of tokens. */
     final ArrayList<String> indexTokens = parseToIndexTokens(context, index);
@@ -180,7 +191,6 @@ public class SmartDialPrefix {
         }
       }
     }
-
     return result;
   }
 
@@ -253,10 +263,9 @@ public class SmartDialPrefix {
          * If the number does not start with '+', finds out whether it is in NANP format and has '1'
          * preceding the number.
          */
-        if ((normalizedNumber.length() == 11)
-            && (normalizedNumber.charAt(0) == '1')
-            && (userInNanpRegion)) {
-          countryCode = "1";
+        if ((normalizedNumber.length() == 11) && (normalizedNumber.charAt(0) == '1'
+                || normalizedNumber.charAt(0) == '7') && (userInNanpRegion)) {
+          countryCode = normalizedNumber.substring(0, 1);
           countryCodeOffset = number.indexOf(normalizedNumber.charAt(1));
           if (countryCodeOffset == -1) {
             countryCodeOffset = 0;
@@ -273,7 +282,8 @@ public class SmartDialPrefix {
            * code, and finds out offset of the local number.
            */
           areaCode = normalizedNumber.substring(0, 3);
-        } else if (countryCode.equals("1") && normalizedNumber.length() == 11) {
+        } else if ((countryCode.equals("1") || countryCode.equals("7")) &&
+                normalizedNumber.length() == 11) {
           /**
            * If the number has country code '1', finds out area code and offset of the local number.
            */
-- 
2.20.1

